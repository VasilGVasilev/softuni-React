Component: basic idea Presentation Fundamental points

    Props
        Props get passed to the component -> like function params
        State is managed within the component -> like local variables

        Components cannot change their own props

        Use children property to access information between opening and closing tags:

            const BookList = () => {
                return (
                    <ul>
                        <Book>
                            <span>
                                Some value
                            </span>
                        </Book>
                    </ul>
                )
            }

            const Book = (props) => {
                return (
                    <li className = 'book'>
                        <div>{props.children}</div>
                    </li>
                )
            }

        
    State Hook - using useState() will preserve this state between re-renders

        useState() overwrite, this.setState merges
        
            useState() is different from this.setState in not merging old and new state together:
            
                this.setState({ selected: { id: 1, name: 'Foobar' } });  

            Then if you update the state:

                this.setState({ selected: { name: 'Barfoo' }});

            - this.setState will merge:

                { selected: { id: 1, name: 'Barfoo' } }; 
            
            - useState() will overwrite:

                { selected: { name: 'Barfoo' } }; 
            
            !THE REASON -> this.setState uses object, useState() does not by default, but it can
        
        Handling events

            Revisiting an old issue with class components:

                ?Why is it necessary to bind 'this' in the following code?

                    class Toggle extends React.Component {
                        constructor(props) {
                            super(props);
                            this.state = {isToggleOn: true};

                            // This binding is necessary to make `this` work in the callback    <--- ?????
                            this.handleClick = this.handleClick.bind(this);  
                        }

                        handleClick() {    
                            this.setState(prevState => ({      
                                isToggleOn: !prevState.isToggleOn    
                            }));  
                        }
                        render() {
                            return (
                                <button onClick={this.handleClick}>        
                                    {this.state.isToggleOn ? 'ON' : 'OFF'}
                                </button>
                            );
                        }
                    }


                The problem is that we do not invoke handleClick in <button onClick={this.handleClick'()'}> directly
                When the app executes the handleClick (wihtout'()') it sort of takes a shallow template of the function
                This shallow template refers to this, which wihtout attached context (via bind()) is practically outside
                the context we define in contructor. Thus, this refers to global object, it has no property setState.

                This is a rule in JS - class methods do not bind by default with context:

                    this.x = 9; // 'this' refers to the global object (e.g. 'window') in non-strict mode

                    const module = {
                        x: 81,
                        getX() {                 //getX: function() is the same but more accessible if necessary
                            return this.x;
                        }
                    };

                    console.log(module.getX()); // 81 Ex.1

                    const retrieveX = module.getX;
                    console.log(retrieveX()); // 9; Ex.2

                    const boundGetX = retrieveX.bind(module);
                    console.log(boundGetX()); // 81 Ex.3
                
                !!!! It is crucial where the function gets invoked:
                    -Ex.1, we directly trigger the module to execute its methods
                    -Ex.2, we abstract a reference/path to the shallow template of the a method of a class, but
                    if we store it in a variable and execute it, this shallow template is shallow and it does not
                    carry the context of its original class, all it knows it is that:
                        -it returns this.x 
                        -it is invoked in the global scope
                    the resulting behaviour is that it searches for this.x value in the context of execution -> global
                    -Ex.3, we bind a context to the shallow template of the method of a class, so that wherever this
                    shallow template is invoked, it has a wrapper function that represents the framework of its scope,
                    this never goes outside this wrapper to rely on the global context by taking the value of this.x = 9;

            Passing arguments to event handlers:
                -arrow functrions:
                    <button onClick={(e)=>this.deleteRow(id,e)} />
                -using bind:
                    <button onClick={this.deleteRow.bind(this, id)} />
                    
            Chat OpenAI explanation:

            Arrow functions in JavaScript have a lexical this binding, which means that they inherit the this 
            context from the surrounding scope, rather than creating a new this context or using the global 
            this. In the case of the functional component, the arrow function is defined inside the 
            component's function body, and therefore inherits the this context of the component. This 
            allows the function to access any properties or methods on the component that are declared 
            with the this keyword.

            Without the arrow function, the this keyword inside the callback function would refer to the
            global object or undefined in strict mode, and the component's method would not be accessible, 
            resulting in an error. The use of the arrow function ensures that the this context inside 
            the callback function is the same as the this context outside of it, thus allowing the 
            component's method to be accessed and executed properly.

            In summary:
                this inside a callback, typically, is undefined which automatically (in non-strict mode) renders
                the value of this to be the Global Object. Thus, we have two options:
                - use an arrow function which has lexical binding -> here, component context
                - use bind() to bind the context;
                so problem of callback rendering this to be undefined -> Global Obj is solved with arrow function or bind()
            
            My explanation on bind:

            So why using bind ->   CLASS METHODS DO NOT BIND WITH CONTEXT BY DEFAULT and in reality,
            after return, the execution of the function is stopped and JSX elements are after the return,
            thus, they do not carry the context and when we call on a method, the method has no context to
            to properties unless .bind() is used

                function m() {
                    this.x = 6
                    return x
                }
                x will refer to global Object not the in m() defined 6
            
            view return as a crucial point of ending the functional scope of m();
            !!!!!! 'this' is just made this way, to always refer to the context and if not -> to global object;
                    this and callbacks

                    this (for normal functions) is determined when a function is called based 
                    on how the function is called. The runtime looks at the reference used to 
                    call the function to see what object is to be used for the value of this
                    When you pass a function to another function as a callback, that function 
                    isn't getting called right away. You're giving up control of the call to 
                    that other function. But when that function gets your function, it gets 
                    it as a single function reference, not as a combination of an object and 
                    a function to call from that object.
            
            if we had a normal variable that stores a value, it would be different:

                function m() {
                    x = 6
                    return x
                }
                x will 6